* Overview
Small collection of utilities that hasn't yet justified their own repositories.
** yamq
A persistant priority queue with the ability to set 'due' time on enqueued items.

*** Example
#+BEGIN_SRC Erlang
%% start your storage backend (postgres/riak/ETS/etc)
%% for this example we use a gen_server keeping track of a dets table. Source
%% is found in test/
{ok, _} = yamq_dets_store:start_link("foo.dets"),

%% define a function that does something with enqueued items
F = fun(Task) ->
      io:format("got a task ~p", [Task]),
      do_something(Task)
    end,

{ok, _} = yamq:start_link([ {store, yamq_dets_store}
                            %% function that will be executed for enqueued
                            %% tasks
                          , {func, F}
                            %% number of concurrent workers
                          , {workers, 4}
                          ]),

%% enqueue a task with priority 1 that will be handled as soon as
%% there is a worker thread ready
ok = yamq:enqueue(foo, [{priority, 1}]),

%% enqueue a task with priority 8 that will be handled in 10minutes or later
ok = yamq:enqueue(bar, [{priority, 8}, {due, 600000}]),

%% enqueue three tasks and make sure they are executed in serial
SerializeID = 123456789,
ok = yamq:enqueue(baz, [{serialize, SerializeID}]),
ok = yamq:enqueue(buz, [{serialize, SerializeID}]),
ok = yamq:enqueue(bar, [{serialize, SerializeID}]),

%% stop queue
ok = yamq:stop(),
#+END_SRC

*** Internals
Very brief:
- Upon startup store is consulted in order to rebuild index
- New items are written to store before they are executed
- 8 priority levels, one ETS table (ordered_set) / level

*** Store
Needs to look somewhat like this
#+BEGIN_SRC Erlang
-module(yamq_store_impl).
-behaviour(yamq_store).

-export([ get/1
        , put/2
        , delete/1
        , list/0
        ]).

get(K)    -> {ok, V}.
put(K,V)  -> ok.
delete(K) -> ok.
list()    -> {ok, []}.
#+END_SRC

*** Performance
Some rough estimates can be found in test/perf1.erl.

My thinkpad x230 handled several million entries with a due time from now to
+6 months without any problems which is more than good enough for my
usecase.
